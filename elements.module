<?php

/**
 * Implements hook_element_info().
 */
function elements_element_info() {
  $types['emailfield'] = array(
    '#input' => TRUE,
    '#size' => 60,
    '#maxlength' => 128,
    '#autocomplete_path' => FALSE,
    '#process' => array('ajax_process_form', 'elements_process_pattern'),
    '#element_validate' => array('elements_validate_email'),
    '#theme' => 'emailfield',
    '#theme_wrappers' => array('form_element'),
  );
  $types['searchfield'] = array(
    '#input' => TRUE,
    '#size' => 60,
    '#maxlength' => 128,
    '#autocomplete_path' => FALSE,
    '#process' => array('ajax_process_form'),
    '#theme' => 'searchfield',
    '#theme_wrappers' => array('form_element'),
  );
  $types['telfield'] = array(
    '#input' => TRUE,
    '#size' => 20,
    '#maxlength' => 64,
    '#process' => array('ajax_process_form', 'elements_process_pattern'),
    '#theme' => 'telfield',
    '#theme_wrappers' => array('form_element'),
  );
  $types['urlfield'] = array(
    '#input' => TRUE,
    '#size' => 80,
    '#maxlength' => 128,
    '#autocomplete_path' => FALSE,
    '#process' => array('ajax_process_form', 'elements_process_pattern'),
    '#element_validate' => array('elements_validate_url'),
    '#theme' => 'urlfield',
    '#theme_wrappers' => array('form_element'),
  );
  $types['numberfield'] = array(
    '#input' => TRUE,
    '#process' => array('ajax_process_form'),
    '#theme' => 'numberfield',
    '#theme_wrappers' => array('form_element'),
  );
  $types['rangefield'] = array(
    '#input' => TRUE,
    '#process' => array('ajax_process_form'),
    '#theme' => 'rangefield',
    '#theme_wrappers' => array('form_element'),
  );

  return $types;
}

/**
 * Implements hook_element_info_alter().
 */
function elements_element_info_alter(&$types) {
  // Add placeholder and pattern support to core form elements.
  foreach (array_keys($types) as $type) {
    switch ($type) {
      case 'textfield':
      case 'textarea':
      case 'password':
        $types[$type]['#process'][] = 'elements_process_placeholder';
        $types[$type]['#process'][] = 'elements_process_pattern';
        break;
    }
  }
}

/**
 * Implements hook_theme().
 */
function elements_theme() {
  return array(
    'emailfield' => array(
      'arguments' => array('element' => NULL),
      'render element' => 'element',
      'file' => 'elements.theme.inc',
    ),
    'searchfield' => array(
      'arguments' => array('element' => NULL),
      'render element' => 'element',
      'file' => 'elements.theme.inc',
    ),
    'telfield' => array(
      'arguments' => array('element' => NULL),
      'render element' => 'element',
      'file' => 'elements.theme.inc',
    ),
    'urlfield' => array(
      'arguments' => array('element' => NULL),
      'render element' => 'element',
      'file' => 'elements.theme.inc',
    ),
    'numberfield' => array(
      'arguments' => array('element' => NULL),
      'render element' => 'element',
      'file' => 'elements.theme.inc',
    ),
    'rangefield' => array(
      'arguments' => array('element' => NULL),
      'render element' => 'element',
      'file' => 'elements.theme.inc',
    ),
  );
}

/**
 * Return the autocompletion HTML for a form element.
 *
 * @param $element
 *   The renderable element to process for autocompletion.
 *
 * @return
 *   The rendered autocompletion element HTML, or an empty string if the field
 *   has no autocompletion enabled.
 */
function elements_add_autocomplete(&$element) {
  $extra = '';

  if (!empty($element['#autocomplete_path']) && drupal_valid_path($element['#autocomplete_path'])) {
    drupal_add_library('system', 'drupal.autocomplete');
    $element['#attributes']['class'][] = 'form-autocomplete';

    $attributes = array();
    $attributes['type'] = 'hidden';
    $attributes['id'] = $element['#attributes']['id'] . '-autocomplete';
    $attributes['value'] = url($element['#autocomplete_path'], array('absolute' => TRUE));
    $attributes['disabled'] = 'disabled';
    $attributes['class'][] = 'autocomplete';
    $extra = '<input' . drupal_attributes($attributes) . ' />';
  }

  return $extra;
}

/**
 * #process callback for #placeholder form element property.
 *
 * @param $element
 *   An associative array containing the properties and children of the
 *   generic input element.
 *
 * @return
 *   The processed element.
 */
function elements_process_placeholder($element) {
  if (isset($element['#placeholder']) && !isset($element['#attributes']['placeholder'])) {
    $element['#attributes']['placeholder'] = $element['#placeholder'];
  }

  return $element;
}

/**
 * #process callback for #pattern form element property.
 *
 * @param $element
 *   An associative array containing the properties and children of the
 *   generic input element.
 *
 * @return
 *   The processed element.
 *
 * @see elements_validate_pattern()
 */
function elements_process_pattern($element) {
  if (isset($element['#pattern']) && !isset($element['#attributes']['pattern'])) {
    $element['#attributes']['pattern'] = $element['#pattern'];
    $element['#element_validate'][] = 'form_validate_pattern';
  }

  return $element;
}

/**
 * #element_validate callback for #pattern form element property.
 *
 * @param $element
 *   An associative array containing the properties and children of the
 *   generic form element.
 * @param $form_state
 *   The $form_state array for the form this element belongs to.
 *
 * @see element_process_pattern()
 */
function elements_validate_pattern($element, &$form_state) {
  if ($element['#value'] !== '') {
    // The pattern must match the entire string and should have the same
    // behavior as the RegExp object in ECMA 262.
    // - Use bracket-style delimiters to avoid introducing a special delimiter
    //   character like '/' that would have to be escaped.
    // - Put in brackets so that the pattern can't interfere with what's
    //   prepended and appended.
    $pattern = '{^(?:' . $element['#pattern'] . ')$}';

    if (!preg_match($pattern, $element['#value'])) {
      form_error($element, t('%name field is not in the right format.', array('%name' => $element['#title'])));
    }
  }
}

/**
 * Form element validation handler for #type 'email'.
 *
 * Note that #maxlength and #required is validated by _form_validate() already.
 */
function elements_validate_email(&$element, &$form_state) {
  if ($element['#value'] && !valid_email_address($element['#value'])) {
    form_error($element, t('The e-mail address %mail is not valid.', array('%mail' => $element['#value'])));
  }
}

/**
 * Form element validation handler for #type 'url'.
 *
 * Note that #maxlength and #required is validated by _form_validate() already.
 */
function elements_validate_url(&$element, &$form_state) {
  if ($element['#value'] && !valid_url($element['#value'], TRUE)) {
    form_error($element, t('The URL %url is not valid.', array('%url' => $element['#value'])));
  }
}
